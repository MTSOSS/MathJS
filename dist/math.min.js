"use strict";function getUnits(a){a=a.toString();const b=a.match(/(?!\b(pi|tau)\b)\b[a-z]+\b/gi);return math.debuggingMode?console.log("Units:",b):null,b?b.join(""):""}function convertToRadians(a){var b=Math.PI;let c=math.evaluate(a.toString().replace(/(?<![a-zA-Z])(pi|tau)(?![a-zA-Z])|[a-zA-Z]/gi,(a,b)=>b?a:""),{});if("deg"==getUnits(a)||""==getUnits(a))return c*b/180;if("grad"==getUnits(a))return c*b/200;if("rad"==getUnits(a))return c;throw new Error("Invalid Unit")}const math={debuggingMode:!1,e:Math.E,PI:Math.PI,LN2:Math.LN2,LN10:Math.LN10,TAU:2*Math.PI,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,EPSILON:Number.EPSILON,PHI:(1+Math.sqrt(5))/2,add:(...a)=>a.reduce((c,a)=>c+a,0),subtract:(...a)=>a.reduce((c,a)=>c-a),multiply:(...a)=>a.reduce((c,a)=>c*a),divide:(...a)=>a.reduce((c,a)=>c/a),remainder:(a,b)=>a%b,max:(...a)=>Math.max(...a),min:(...a)=>Math.min(...a),average:(...a)=>a.reduce((c,a)=>c+a,0)/a.length,mean:(...a)=>math.average(...a),median:(...a)=>{a.sort((c,a)=>c-a);const b=Math.floor(a.length/2);return 0==a.length%2?(a[b-1]+a[b])/2:a[b]},mode:(...a)=>{let b="Str";"string"==typeof a[a.length-1]&&["Str","Arr"].includes(a[a.length-1].toString())&&(b=a.pop());const c={};a.forEach(a=>c[a]=(c[a]||0)+1);let d=0,f=[];for(const b in c)c[b]>d?(f=[parseInt(b)],d=c[b]):c[b]===d&&f.push(parseInt(b));return"Str"===b?f.join(", "):f},range:(...a)=>{let b="Str";"string"==typeof a[a.length-1]&&["Str","Arr"].includes(a[a.length-1])&&(b=a.pop());const c=a.filter(a=>"number"==typeof a);c.sort((c,a)=>c-a);const d=[c[0],c[c.length-1]];return"Str"===b?d.join(", "):d},variance:(...a)=>{const b=math.mean(...a);return math.mean(...a.map(a=>math.square(a-b)))},standardDeviation:(...a)=>Math.sqrt(math.variance(...a)),isEqual:(c,a)=>c===a,isNearlyEqual:(c,a,b=Number.EPSILON)=>Math.abs(c-a)<b,isEven:a=>0==a%2,isOdd:a=>0!=a%2,isPositive:a=>0<a,isNegative:a=>0>a,isZero:a=>0===a,isInteger:a=>Number.isInteger(a),isFloat:a=>+a===a&&0!=a%1,isPrime:a=>{if(1===a||2>a)return!1;for(let b=2;b<a;b++)if(0==a%b)return!1;return!0},isComposite:a=>!math.isPrime(a),isDivisible:(a,b)=>0==a%b,isPowerOf:(a,b)=>0==Math.log(a)/Math.log(b)%1,isPerfectSquare:a=>0==Math.sqrt(a)%1,isPerfectCube:a=>0==Math.cbrt(a)%1,isPerfectPower:(a,c)=>0==Math.log(a)/Math.log(c)%1,isMultiple:(a,b)=>0==a%b,isFactor:(a,b)=>0==b%a,isArmstrong:c=>c===c.toString().split("").reduce((d,a)=>d+Math.pow(parseInt(a),c.toString().length),0),isPalindrome:a=>a.toString()===a.toString().split("").reverse().join(""),isFinite:a=>Number.isFinite(a),isInfinite:a=>!Number.isFinite(a),factorial:a=>{let b=1;if(0===a)return 1;for(let c=2;c<=a;c++)b*=c;return b},fibonacci:c=>{let d,e=1,f=0;for(;0<=c;c--)d=e,e+=f,f=d;return f},fibonacciSeries:(a,b="Str")=>{const c=Array.from({length:a},(a,b)=>math.fibonacci(b));return"Str"===b?c.join(", "):c},random:(c,a)=>Math.floor(Math.random()*(a-c+1))+c,log:(a,c)=>{var b=Math.log;if(c!==void 0){const d=b(a)/b(c);return+d.toFixed(2)}const d=b(a);return+d.toFixed(2)},logBase2:a=>Math.log2(a),logBase5:a=>Math.log(a)/Math.log(5),logBase10:a=>Math.log10(a),square:a=>a**2,cube:a=>a**3,power:(a,b)=>a**b,root:(a,b)=>a**(1/b),round:a=>Math.round(a),roundUp:a=>Math.ceil(a),roundDown:a=>Math.floor(a),absolute:a=>Math.abs(a),sqrt:a=>Math.sqrt(a),cbrt:a=>Math.cbrt(a),hypotenuse:(c,a)=>Math.hypot(c,a),factorsOf:(a,b="Arr")=>{const c=[];for(let d=1;d<=a;d++)0==a%d&&c.push(d);return"Str"===b?c.join(", "):c},primeFactorsOf:(a,b="Arr")=>{const c=[];for(let d=2;d<=a;d++)for(;0==a%d;)c.includes(d)||c.push(d),a/=d;return"Str"===b?c.join(", "):c},primeFactorizationOf:(a,b="Arr")=>{var c=Math.sqrt;const d=[];for(let e=2;e<=c(a);e++)for(;0==a%e;)d.push(e),a/=e;return 1<a&&d.push(a),"Str"===b?d.join(", "):d},greatestCommonDivisor:(...a)=>{const c=(a,b)=>b?c(b,a%b):a;return a.reduce((d,a)=>c(d,a))},GCD:(...a)=>math.greatestCommonDivisor(...a),highestCommonFactor:(...a)=>math.greatestCommonDivisor(...a),HCF:(...a)=>math.greatestCommonDivisor(...a),leastCommonMultiple:(...a)=>{const c=(a,b)=>b?c(b,a%b):a,d=(b,d)=>b*d/a.reduce((d,a)=>c(d,a));return a.reduce((c,a)=>d(c,a))},LCM:(...a)=>math.leastCommonMultiple(...a),sin:a=>{const b=Math.sin(convertToRadians(a));return+b.toFixed(2)},cos:a=>{const b=Math.cos(convertToRadians(a));return+b.toFixed(2)},tan:a=>{const b=Math.tan(convertToRadians(a));return+b.toFixed(2)},cot:a=>{const b=1/Math.tan(convertToRadians(a));return+b.toFixed(2)},sec:a=>{const b=1/Math.cos(convertToRadians(a));return+b.toFixed(2)},csc:a=>{const b=1/Math.sin(convertToRadians(a));return+b.toFixed(2)},asin:a=>{const b=Math.asin(convertToRadians(a));return+b.toFixed(2)},acos:a=>{const b=Math.acos(convertToRadians(a));return+b.toFixed(2)},atan:a=>{const b=Math.atan(convertToRadians(a));return+b.toFixed(2)},acot:a=>{const b=1/Math.atan(convertToRadians(a));return+b.toFixed(2)},asec:a=>{const b=1/Math.acos(convertToRadians(a));return+b.toFixed(2)},acsc:a=>{const b=1/Math.asin(convertToRadians(a));return+b.toFixed(2)},sinh:a=>{const b=Math.sinh(convertToRadians(a));return+b.toFixed(2)},cosh:a=>{const b=Math.cosh(convertToRadians(a));return+b.toFixed(2)},tanh:a=>{const b=Math.tanh(convertToRadians(a));return+b.toFixed(2)},coth:a=>{const b=1/Math.tanh(convertToRadians(a));return+b.toFixed(2)},sech:a=>{const b=1/Math.cosh(convertToRadians(a));return+b.toFixed(2)},csch:a=>{const b=1/Math.sinh(convertToRadians(a));return+b.toFixed(2)},asinh:a=>{const b=Math.asinh(convertToRadians(a));return+b.toFixed(2)},acosh:a=>{const b=Math.acosh(convertToRadians(a));return+b.toFixed(2)},atanh:a=>{const b=Math.atanh(convertToRadians(a));return+b.toFixed(2)},acoth:a=>{const b=1/Math.atanh(convertToRadians(a));return+b.toFixed(2)},asech:a=>{const b=1/Math.acosh(convertToRadians(a));return+b.toFixed(2)},acsch:a=>{const b=1/Math.asinh(convertToRadians(a));return+b.toFixed(2)},evaluate:(a,b)=>{try{if("string"!=typeof a)throw new Error("Expression must be a string");if(b)for(let c in b){const d=new RegExp("\\b"+c+"\\b","g");a=a.replace(d,b[c].toString())}for(let b in a=a.replace(/\^/g,"**").replace(/รท/g,"/").replace(/ร/g,"*").replace(/\bpi\b/gi,"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679").replace(/\btau\b/gi,"6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341358"),math)if("pi"!=b&&"tau"!==b){const c=new RegExp(`\\b${b}\\b`,"g");a=a.replace(c,`math['${b}']`)}const c=/^[\d\s+\-*/()a-zA-Z"''\[\].,]+$/;for(let b=0;b<a.length;b++)if(!c.test(a[b]))throw new Error(`Expression contains disallowed character: ${a[b]} at character position: ${b} in expression: ${a}`);return math.debuggingMode?console.log("Expression:",a):null,Function("math",`'use strict'; return (${a})`)(math)}catch(a){throw new Error("Error occurred while evaluating the expression: "+a)}},chain:a=>{let b=a;const c={};for(const d in math)"function"==typeof math[d]&&"chain"!==d&&(c[d]=(...a)=>{try{"number"==typeof b&&(b=math[d](b,...a))}catch(a){console.error(`Error executing method ${d}:`,a)}return c});if(c.result=()=>b,"number"==typeof a)return c;throw new Error("Initial value must be a number")}};(function(a,b){"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?module.exports=b():"object"==typeof module&&"object"==typeof module.exports?(module.exports=b(),module.exports.default=b()):a.math=b()})("undefined"==typeof self?this:self,function(){return math});