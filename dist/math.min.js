"use strict";function getUnits(a){a=a.toString();const b=a.match(/(?!\b(pi|tau)\b)\b[a-z]+\b/gi);return math.debuggingMode?console.log("Units:",b):null,b?b.join(""):""}function convertToRadians(a){var b=Math.PI;let c=math.evaluate(a.toString().replace(/(?<![a-zA-Z])(pi|tau)(?![a-zA-Z])|[a-zA-Z]/gi,(a,b)=>b?a:""),{});switch(getUnits(a)){case"deg":case"":return c*b/180;case"grad":return c*b/200;case"rad":return c;default:throw new Error("Invalid Unit")}}function validateAngle(a,b){var c=Number.POSITIVE_INFINITY,d=Math.PI;return("tan"===b||"sec"===b)&&(a===d/2||a===3*d/2)?c:("cot"===b||"csc"===b)&&(0===a||a===d)?c:a}const math={debuggingMode:!1,e:Math.E,PI:Math.PI,LN2:Math.LN2,LN10:Math.LN10,TAU:2*Math.PI,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,EPSILON:Number.EPSILON,PHI:(1+Math.sqrt(5))/2,add:(...a)=>a.reduce((c,a)=>c+a,0),subtract:(...a)=>a.reduce((c,a)=>c-a),multiply:(...a)=>a.reduce((c,a)=>c*a),divide:(...a)=>a.reduce((c,a)=>c/a),remainder:(...a)=>a.reduce((c,a)=>c%a),max:(...a)=>Math.max(...a),min:(...a)=>Math.min(...a),average:(...a)=>a.reduce((c,a)=>c+a,0)/a.length,mean:(...a)=>math.average(...a),median:(...a)=>{a.sort((c,a)=>c-a);const b=Math.floor(a.length/2);return 0==a.length%2?(a[b-1]+a[b])/2:a[b]},mode:(...a)=>{let b="Str";"string"==typeof a[a.length-1]&&["Str","Arr"].includes(a[a.length-1])&&(b=a.pop());const c={},d=[];let f=0;return a.forEach(a=>{const b="string"==typeof a?`s_${a}`:a.toString();c[b]=(c[b]||0)+1,c[b]>f?(d.splice(0,d.length,a),f=c[b]):c[b]===f&&d.push(a)}),"Str"===b?d.map(a=>"string"==typeof a?a:a.toString()).join(", "):d},range:(...a)=>{let b="Str";"string"==typeof a[a.length-1]&&["Str","Arr"].includes(a[a.length-1])&&(b=a.pop());const c=a.filter(a=>"number"==typeof a),d=Math.min(...c),e=Math.max(...c),f=[d,e];return"Str"===b?f.join(", "):f},variance:(...a)=>{const b=math.mean(...a);return math.mean(...a.map(a=>math.square(a-b)))},standardDeviation:(...a)=>Math.sqrt(math.variance(...a)),isEqual:(c,a)=>c===a,isNearlyEqual:(c,a,b=Number.EPSILON)=>Math.abs(c-a)<b,isEven:a=>0==a%2,isOdd:a=>0!=a%2,isPositive:a=>0<a,isNegative:a=>0>a,isZero:a=>0===a,isInteger:a=>Number.isInteger(a),isFloat:a=>+a===a&&0!=a%1,isPrime:a=>{if(2===a)return!0;if(1===a||0==a%2)return!1;const b=Math.sqrt(a);for(let c=3;c<=b;c+=2)if(0==a%c)return!1;return!0},isComposite:a=>!math.isPrime(a),isDivisible:(a,b)=>0==a%b,isPowerOf:(a,b)=>0==Math.log(a)/Math.log(b)%1,isPerfectSquare:a=>0==Math.sqrt(a)%1,isPerfectCube:a=>0==Math.cbrt(a)%1,isPerfectPower:(a,c)=>0==Math.log(a)/Math.log(c)%1,isMultiple:(a,b)=>0==a%b,isFactor:(a,b)=>0==b%a,isArmstrong:c=>c===c.toString().split("").reduce((d,a)=>d+Math.pow(parseInt(a),c.toString().length),0),isPalindrome:a=>a.toString()===a.toString().split("").reverse().join(""),isFinite:a=>Number.isFinite(a),isInfinite:a=>!Number.isFinite(a),factorial:a=>{if(0===a)return 1;let b=1;for(let c=1;c<=a;c++)b*=c;return b},fibonacci:c=>{let d=0,e=1;for(let a=2;a<=c;a++)[d,e]=[e,d+e];return e},fibonacciSeries:(a,b="Str")=>{const c=Array.from({length:a},(a,b)=>math.fibonacci(b));return"Str"===b?c.join(", "):c},random:(c,a)=>Math.floor(Math.random()*(a-c+1))+c,log:(a,c)=>{var b=Math.log;if(c!==void 0){const d=b(a)/b(c);return+d.toFixed(2)}const d=b(a);return+d.toFixed(2)},logBase2:a=>Math.log2(a),logBase5:a=>Math.log(a)/Math.log(5),logBase10:a=>Math.log10(a),square:a=>a**2,cube:a=>a**3,power:(a,b)=>a**b,root:(a,b)=>a**(1/b),round:a=>Math.round(a),roundUp:a=>Math.ceil(a),roundDown:a=>Math.floor(a),absolute:a=>Math.abs(a),sqrt:a=>Math.sqrt(a),cbrt:a=>Math.cbrt(a),hypotenuse:(c,a)=>Math.hypot(c,a),factorsOf:(a,b="Arr")=>{const c=[];for(let d=1;d<=a;d++)0==a%d&&c.push(d);return"Str"===b?c.join(", "):c},primeFactorsOf:(a,b="Arr")=>{const c=[];for(let d=2;d<=a;d++)for(;0==a%d;)c.includes(d)||c.push(d),a/=d;return"Str"===b?c.join(", "):c},primeFactorizationOf:(a,b="Arr")=>{var c=Math.sqrt;const d=[];for(let e=2;e<=c(a);e++)for(;0==a%e;)d.push(e),a/=e;return 1<a&&d.push(a),"Str"===b?d.join(", "):d},greatestCommonDivisor:(...a)=>{const c=(a,b)=>b?c(b,a%b):a;return a.reduce((d,a)=>c(d,a))},GCD:(...a)=>math.greatestCommonDivisor(...a),highestCommonFactor:(...a)=>math.greatestCommonDivisor(...a),HCF:(...a)=>math.greatestCommonDivisor(...a),leastCommonMultiple:(...a)=>{const c=(a,b)=>b?c(b,a%b):a,d=(b,d)=>b*d/a.reduce((d,a)=>c(d,a));return a.reduce((c,a)=>d(c,a))},LCM:(...a)=>math.leastCommonMultiple(...a),sin:a=>{const b=convertToRadians(a),c=Math.sin(b);return+c.toFixed(2)},cos:a=>{const b=convertToRadians(a),c=Math.cos(b);return+c.toFixed(2)},tan:a=>{const b=validateAngle(convertToRadians(a),"tan"),c=Math.tan(b);return+c.toFixed(2)},cot:a=>{const b=validateAngle(convertToRadians(a),"cot"),c=1/Math.tan(b);return+c.toFixed(2)},sec:a=>{const b=validateAngle(convertToRadians(a),"sec"),c=1/Math.cos(b);return+c.toFixed(2)},csc:a=>{const b=validateAngle(convertToRadians(a),"csc"),c=1/Math.sin(b);return+c.toFixed(2)},evaluate:(a,b)=>{try{if("string"!=typeof a)throw new Error("Expression must be a string");if(a=a.replace(/(\d)(?=[a-zA-Z])/g,"$1*"),b)for(let c in b){const d=new RegExp("\\b"+c+"\\b","g");a=a.replace(d,b[c].toString())}for(let b in a=a.replace(/\^/g,"**").replace(/รท/g,"/").replace(/ร/g,"*").replace(/\bpi\b/gi,"PI").replace(/\btau\b/gi,"TAU"),math)if("pi"!=b&&"tau"!==b){const c=new RegExp(`\\b${b}\\b`,"g");a=a.replace(c,`math['${b}']`)}const c=/^[\d\s+\-*/()a-zA-Z"''\[\].,]+$/;for(let b=0;b<a.length;b++)if(!c.test(a[b]))throw new Error(`Expression contains disallowed character: ${a[b]} at character position: ${b} in expression: ${a}`);return math.debuggingMode?console.log("Expression:",a):null,Function("math",`'use strict'; return (${a})`)(math)}catch(a){throw new Error("Error occurred while evaluating the expression: "+a)}},chain:(a=0)=>{let b=a;const c={};for(const d in math)"function"==typeof math[d]&&"chain"!==d&&(c[d]=(...a)=>{try{"number"==typeof b&&(b=math[d](b,...a))}catch(a){console.error(`Error executing method ${d}:`,a)}return c});if(c.result=()=>b,"number"==typeof a)return c;throw new Error("Initial value must be a number")}};(function(a,b){"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?module.exports=b():"object"==typeof module&&"object"==typeof module.exports?(module.exports=b(),module.exports.default=b()):a.math=b()})("undefined"==typeof self?this:self,function(){return math});